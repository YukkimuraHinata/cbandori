# cbandori
邦多利（GBP,ガルパ）抽卡模拟,bangdream-gacha的C语言版本。

名字来源于一个叫cbonsai的Linux程序，它的作用是在你的终端显示一盆盆栽，想必市谷有咲会喜欢的。

#### 介绍
邦多利当期新卡期望抽数模拟：基于玩家输入的卡池信息，通过模拟抽卡帮助玩家预测抽到心仪卡片所需的平均抽卡次数，优化游戏体验（够呛，因为武士道这排期就是故意恶心人）。

此版本为修改版，源项目地址见[gitee](https://gitee.com/handsome-druid/bangdream-gacha)

我修改的C++版本见[这里](https://github.com/YukkimuraHinata/bangdream-gacha)

#### 安装教程

请使用gcc或其它支持C23的编译器编译:

gcc -c myset.c -O2

gcc cbandori.c myset.o -o cbandori -pthread -O2

其实你引一个stdbool头文件之后就能在C11标准下编译了，也许C99也行？

非Windows用户请注意线程获取和计时相关的代码是不跨平台的，需要移植

#### 使用说明

1.  输入当期5星新卡的总数
2.  输入想要的当期5星卡数量（可以为0）
3.  输入想要的当期4星卡数量（可以为0）
4.  选择是否为常驻池（是否有50抽保底）
5.  使用 -r 参数反推你所使用的抽数在所有模拟情况中的排名
6.  使用 -n 模拟次数 （如-n 200000）指定模拟次数，默认为十万次
7.  使用 -t 参数指定模拟所使用的线程（默认为CPU线程的一半）

例1. 本期有4张新5星，1张新4星，想抽其中的2张5星卡和1张4星卡，则5星数量输入5，第二个5星数量输入2，4星数量输入1

例2. 本期有5张新5星，想抽全部5张卡，则5星数量输入5，第二个5星数量也输入5，4星数量输入0

#### 特别说明

1. 本程序没有针对fes和普限卡池做出区分，因为这两种卡池出某一张当期5星的概率均为0.5%，和常驻池是一样的。

2. fes池仅仅提升了任意5星和4星的出货率，但对于当期4，5星的出率没有调整。

3. 要求输入当期5星新卡总数是因为5星卡会分摊掉小保底的概率，4星卡本身就没有小保底，所以不需要输入当期4星新卡的总数。

4. 由于常驻池小保底必定不能出4星，当期4星在常驻池所需的平均抽数，应该比它在限定池所需的平均抽数大一点点。

#### 碎碎念时间

1. 把代码从C++反向移植到C语言起因是灵机一动，随后便新建文件夹，挖了个大坑。 于是我一边实习一边慢慢思考该如何移植它。 在终于下定决心开工后的9天后，这玩意的单线程版本终于跑起来了，但是当时也没感到高兴，只在感慨jtty怎么又出事了…… 

2. 开工半个月后的今天（2025.7.29），它终于以多线程的方式运行了起来，尽管相比于C++版本，它仍缺少一些功能（指结果高亮显示，其实就是懒）。 cout确实挺好的，如果它不把uint8_t当成char打印出来就更好了。 

3. 在修复了无数的double free，数组越界访问，段错误，传错参数导致的逆天问题，传了函数的地址而不是它的返回值导致if判断始终为true，以及根本不知道发生在那的隐式转换之后，它应该是内存比较安全的了。

4. 移植过程中的最大感受是：怎么这么写在C++里可以，在C里面就不行；怎么这么写在Linux里可以，在Windows里面就不行；怎么这么写在一个单独的文件里就可以，把它们放一起就不行🤣。

5. 其实我还写了个vector，但是完全没有用上，因为模拟次数是可以确定的，并没有动态伸缩容量的需求。set也是，写着写着才发现对于数值上限确定且不太大的情况，直接用一个数组就行，不需要结构体，但是也懒得改了。

6. 最后，我没有要求你永远保持内存安全，我不是rust的信徒。

    可是，段错误是什么意思？你的栈空间怎么了？你才执行了21步吧？再这样下去，你执行42步错误4次，84步错误8次，最后就造成系统内存泄漏了。

    作为UCRT，我可能得强制return 1。真的。

![VLA并不伟大](/includes/sigsegv.png "Linux内核不让用VLA那是有原因的，你还能有Linus聪明？")
